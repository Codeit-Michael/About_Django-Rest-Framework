## PART 1: SERIALIZATION ##

*Getting Started:
- Let's assume you already install django and rest framework at this time. Also make
sure you 'pip3 install pygments' for text code highlighting. If you want a virtual
environment with django, just type; 'pipenv install django', & type 'deactive' to exit.
If you're ready, lets make our project and app made by django.

- After it, let's list the app and 'rest_framework' in INSTALLED_APPS to access
everything they had.


*Models:
- Let's add model to work with our API. After it, migrate.
from django.db import models
from pygments.lexers import get_all_lexers
from pygments.styles import get_all_styles

LEXERS = [item for item in get_all_lexers() if item[1]]
LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS])
STYLE_CHOICES = sorted([(item, item) for item in get_all_styles()])

class Snippet(models.Model):
    created = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=100, blank=True, default='')
    code = models.TextField()
    linenos = models.BooleanField(default=False)
    language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100)
    style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100)

    class Meta:
        ordering = ['created']


*Serializers:
- Serializers works like a forms which wwork is to proccess the datas into objects such as json, etc. Make a serializers.py on your app directory (like snippets) & type:
from rest_framework import serializers
from snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICES


class SnippetSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(required=False, allow_blank=True, max_length=100)
    code = serializers.CharField(style={'base_template': 'textarea.html'})
    linenos = serializers.BooleanField(required=False)
    language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python')
    style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly')

    def create(self, validated_data):
        """
        Create and return a new `Snippet` instance, given the validated data.
        """
        return Snippet.objects.create(**validated_data)

    def update(self, instance, validated_data):
        """
        Update and return an existing `Snippet` instance, given the validated data.
        """
        instance.title = validated_data.get('title', instance.title)
        instance.code = validated_data.get('code', instance.code)
        instance.linenos = validated_data.get('linenos', instance.linenos)
        instance.language = validated_data.get('language', instance.language)
        instance.style = validated_data.get('style', instance.style)
        instance.save()
        return instance


*Working with Serializers:
- Now let's add some data in db by python3 manage.py shell. Example:

	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer
	from rest_framework.renderers import JSONRenderer
	from rest_framework.parsers import JSONParser

	sn1 = Snippet(code='new = "one"')
	sn1.save()

	sn1 = Snippet(code='print("hello, world")')
	sn1.save()

- Since our sn1's last value is code='print("hello world")', that wil be what we use
in future steps. Now let's serializing that instance by typing ff. in shell:

	srl = SnippetSerializer(sn1)
	srl.data

- At this point we've translated the model instance into Python native datatypes. To finalize the serialization process we render the data into json.
	
	cnt = JSONRenderer().render(srl.data)
	cnt # it returns now the json

- Deserialization is similar. First we parse a stream into Python native datatypes

	import io
	stream = io.BYTESIO(cnt)
	data = JSONParser().parse(stream)

- And we can restore them into native datatypes by:
	
	serializer = SnippetSerializer(data=data)
	serializer.is_valid()
	# True
	serializer.validated_data
	# OrderedDict([('title', ''), ('code', 'print("hello, world")\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])
	serializer.save()
	# <Snippet: Snippet object>


*Working with ModelSerializers:
In the same way that Django provides both Form classes and ModelForm classes, REST
framework includes both Serializer classes, and ModelSerializer classes.
Let's look at refactoring our serializer using the ModelSerializer class. Open the
file snippets/serializers.py again, and replace the SnippetSerializer with the ff:

	class SnippetSerializer(serializers.ModelSerializer):
		class Meta:
			model = Snippet
			fields = ['id', 'title', 'code', 'linenos', 'language', 'style']

- You can analyze the serializer instance of serializers by printing its
representation(repr()) in shell. Once you import SnippetSerializer in
snipppet.serializers try:

	srl = SnippetSerializer()
	print(repr(srl))

- Our modelSerializer is has nothing to do. Just the default create() & update(). It 
all happens because of our class Meta. It dictates our instances how to behave.


*Writing Views using our Serializers:
- The root of our API is going to be a view that supports listing all the existing
snippets, or creating a new snippet:

	from django.http import HttpResponse, JsonResponse
	from django.views.decorators.csrf import csrf_exempt
	from rest_framework.parsers import JSONParser
	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer

	# csrf_exempt because we don't have csrf_token
	@csrf_exempt
	def snippet_list(request):
		"""
		List all code snippets, or create a new snippet.
		"""
		if request.method == 'GET':
			snippets = Snippet.objects.all()
			serializer = SnippetSerializer(snippets, many=True)
			return JsonResponse(serializer.data, safe=False)

		elif request.method == 'POST':
			data = JSONParser().parse(request)
			serializer = SnippetSerializer(data=data)
			if serializer.is_valid():
				serializer.save()
				return JsonResponse(serializer.data, status=201)
			return JsonResponse(serializer.errors, status=400)

- We'll also need a view which corresponds to an individual snippet, and can be used
to retrieve, update or delete the snippet:

	@csrf_exempt
	def snippet_detail(request, pk):
	    """
	    Retrieve, update or delete a code snippet.
	    """
	    try:
	        snippet = Snippet.objects.get(pk=pk)
	    except Snippet.DoesNotExist:
	        return HttpResponse(status=404)

	    if request.method == 'GET':
	        serializer = SnippetSerializer(snippet)
	        return JsonResponse(serializer.data)

	    elif request.method == 'PUT':
	        data = JSONParser().parse(request)
	        serializer = SnippetSerializer(snippet, data=data)
	        if serializer.is_valid():
	            serializer.save()
	            return JsonResponse(serializer.data)
	        return JsonResponse(serializer.errors, status=400)

	    elif request.method == 'DELETE':
	        snippet.delete()
	        return HttpResponse(status=204)

- In able to connect wwith this, we should edit our snippets/urls.py:

	from django.urls import path
	from snippets import views

	urlpatterns = [
		path('snippets/', views.snippet_list),
		path('snippets/<int:pk>/', views.snippet_detail),
	]

- In tutorial/urls.py:
	from django.urls import path, include

	urlpatterns = [
		path('', include('snippets.urls')),
	]

- Now we cam try our code by running the server: python3 manage.py 



## REQUEST AND RESPONSE

*Request objects:
- REST framework introduces a 'Request' object that extends the regular 'HttpRequest',
and provides more flexible request parsing. The core functionality of the 'Request'
object is the 'request.data' attribute, which is similar to 'request.POST', but more
useful for working with Web APIs.
	request.POST  # Only handles form data. Only works for 'POST' method
	request.data  # Handles arbitrary data. Works for 'POST', 'PUT' and 'PATCH' method

*Response objects:
- REST framework also introduces a 'Response' object, which is a type of
TemplateResponse' that takes unrendered content and uses content negotiation to
determine the correct content type to return to the client.
	return Response(data)  # Renders to content type as requested by the client.

*Status code
- Using numeric HTTP status codes in your views doesn't always make for obvious
reading, and it's easy to not notice if you get an error code wrong. REST framework
provides more explicit identifiers for each status code, such as HTTP_400_BAD_REQUEST
in the status module.

*Wrapping API views:
- REST framework provides two wrappers you can use to write API views.
	a. '@api_view' decorator for working with function based views.
		if you're using function api views:
		 -from rest_framework.decorators import api_view
		 -@api_view(['GET', 'POST'])
		 -def snippet_list(request,format=None):

	b. 'APIView' class for working with class-based views.
		if you're using class api views:
		 -from rest_framework.views import APIView
		 -class snippetList(APIView):


- These wrappers provide a few bits of functionality such as making sure you receive 
Request instances in your view, and adding context to Response objects so that 
content negotiation can be performed. The wrappers also provide behaviour such as 
returning 405 Method Not Allowed responses when appropriate, and handling any 
ParseError exceptions that occur when accessing request.data with malformed input.

-Now let's slightly modify the snippet_list() and let's use the '@api_view' decorator:

	from rest_framework import status
	from rest_framework.decorators import api_view
	from rest_framework.response import Response
	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer

	@api_view(['GET', 'POST'])
	def snippet_list(request):
		"""
		List all code snippets, or create a new snippet.
		"""
		if request.method == 'GET':
			snippets = Snippet.objects.all()
			serializer = SnippetSerializer(snippets, many=True)
			return Response(serializer.data)

		elif request.method == 'POST':
			serializer = SnippetSerializer(data=request.data)
			if serializer.is_valid():
				serializer.save()
				return Response(serializer.data, status=status.HTTP_201_CREATED)
			return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

- Also modify the snippe_detail():
	@api_view(['GET', 'PUT', 'DELETE'])
	def snippet_detail(request, pk):
		"""
		Retrieve, update or delete a code snippet.
		"""
		try:
			snippet = Snippet.objects.get(pk=pk)
		except Snippet.DoesNotExist:
			return Response(status=status.HTTP_404_NOT_FOUND)

		if request.method == 'GET':
			serializer = SnippetSerializer(snippet)
			return Response(serializer.data)

		elif request.method == 'PUT':
			serializer = SnippetSerializer(snippet, data=request.data)
			if serializer.is_valid():
				serializer.save()
				return Response(serializer.data)
			return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

		elif request.method == 'DELETE':
			snippet.delete()
			return Response(status=status.HTTP_204_NO_CONTENT)


* Adding optional 'format' suffixes to our URLs:
-  Using format suffixes gives us URLs that explicitly refer to a given format, and 
means our API will be able to handle URLs such as http://example.com/api/items/4.json.
Start by adding a format keyword argument to both of the views:
	def snippet_list(request, format=None), def snippet_detail(request, format=None)

- Modify the snippets/urls.py:
	from django.urls import path
	from snippets import views
	from rest_framework.urlpatterns import format_suffix_patterns

	urlpatterns = [
		path('snippets/', views.snippet_list),
		path('snippets/<int:pk>/', views.snippet_detail),
	]
	urlpatterns = format_suffix_patterns(urlpatterns))

- Now we can test our api after running by:
	http http://127.0.0.1:8000/snippets.json  # JSON suffix
	http http://127.0.0.1:8000/snippets.api   # Browsable API suffix

- Our default client-based response to their request was an HTML formatted page 
for repr (representation).



## CLASS-BASED VIEWS

*Modifying our views to class based api views:

	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer
	from django.http import Http404
	from rest_framework.views import APIView
	from rest_framework.response import Response
	from rest_framework import status

	class SnippetList(APIView):
		"""
		List all snippets, or create a new snippet.
		"""
		def get(self, request, format=None):
			snippets = Snippet.objects.all()
			serializer = SnippetSerializer(snippets, many=True)
			return Response(serializer.data)

		def post(self, request, format=None):
			serializer = SnippetSerializer(data=request.data)
			if serializer.is_valid():
				serializer.save()
				return Response(serializer.data, status=status.HTTP_201_CREATED)
			return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

	class SnippetDetail(APIView):
		"""
		Retrieve, update or delete a snippet instance.
		"""
		def get_object(self, pk):
			try:
				return Snippet.objects.get(pk=pk)
			except Snippet.DoesNotExist:
				raise Http404

		def get(self, request, pk, format=None):
			snippet = self.get_object(pk)
			serializer = SnippetSerializer(snippet)
			return Response(serializer.data)

		def put(self, request, pk, format=None):
			snippet = self.get_object(pk)
			serializer = SnippetSerializer(snippet, data=request.data)
			if serializer.is_valid():
				serializer.save()
				return Response(serializer.data)
			return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

		def delete(self, request, pk, format=None):
			snippet = self.get_object(pk)
			snippet.delete()
			return Response(status=status.HTTP_204_NO_CONTENT)


*Modify our snippets/urls.py/urlpatterns also:

-Before:
	urlpatterns = [
		path('snippets/', views.snippet_list),
		path('snippets/<int:pk>/', views.snippet_detail),
	]

After:
	urlpatterns = [
		path('snippets/', views.SnippetList.as_view()),
		path('snippets/<int:pk>/', views.SnippetDetail.as_view()),
	]


*Using Mixins:

	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer
	from rest_framework import mixins
	from rest_framework import generics

	class SnippetList(mixins.ListModelMixin,
					mixins.CreateModelMixin,
					generics.GenericAPIView):
		queryset = Snippet.objects.all()
		serializer_class = SnippetSerializer

		def get(self, request, *args, **kwargs):
			return self.list(request, *args, **kwargs)

		def post(self, request, *args, **kwargs):
			return self.create(request, *args, **kwargs)

- Here, the 'mixins.ListModeMixin' does the '.list()' job (the get method) and 
'mixins.CreateModeMixin' does the '.create()' job (the post method) while the 
'generics.GenericAPIView' is the responsible of the views just like the APIView on 
class based api view but has limited actions.

	class SnippetDetail(mixins.RetrieveModelMixin,
						mixins.UpdateModelMixin,
						mixins.DestroyModelMixin,
						generics.GenericAPIView):
		queryset = Snippet.objects.all()
		serializer_class = SnippetSerializer

		def get(self, request, *args, **kwargs):
			return self.retrieve(request, *args, **kwargs)

		def put(self, request, *args, **kwargs):
			return self.update(request, *args, **kwargs)

		def delete(self, request, *args, **kwargs):
			return self.destroy(request, *args, **kwargs)
- Pretty similar. Again we're using the GenericAPIView class to provide the core 
functionality, and adding in mixins to provide the '.retrieve()', '.update()' and 
'.destroy()' actions.


*Using generic class-based views:
Using the mixin classes we've rewritten the views to use slightly less code than 
before, but we can go one step further. REST framework provides a set of already 
mixed-in generic views that we can use to trim down our views.py module even more.

	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer
	from rest_framework import generics


	class SnippetList(generics.ListCreateAPIView):
		queryset = Snippet.objects.all()
		serializer_class = SnippetSerializer


	class SnippetDetail(generics.RetrieveUpdateDestroyAPIView):
		queryset = Snippet.objects.all()
		serializer_class = SnippetSerializer