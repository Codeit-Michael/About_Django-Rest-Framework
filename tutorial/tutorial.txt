## PART 1: SERIALIZATION ##

*Getting Started:
- Let's assume you already install django and rest framework at this time. Also make
sure you 'pip3 install pygments' for text code highlighting. If you want a virtual
environment with django, just type; 'pipenv install django', & type 'deactive' to exit.
If you're ready, lets make our project and app made by django.

- After it, let's list the app and 'rest_framework' in INSTALLED_APPS to access
everything they had.


*Models:
- Let's add model to work with our API. After it, migrate.
from django.db import models
from pygments.lexers import get_all_lexers
from pygments.styles import get_all_styles

LEXERS = [item for item in get_all_lexers() if item[1]]
LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS])
STYLE_CHOICES = sorted([(item, item) for item in get_all_styles()])

class Snippet(models.Model):
    created = models.DateTimeField(auto_now_add=True)
    title = models.CharField(max_length=100, blank=True, default='')
    code = models.TextField()
    linenos = models.BooleanField(default=False)
    language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100)
    style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100)

    class Meta:
        ordering = ['created']


*Serializers:
- Serializers works like a forms which wwork is to proccess the datas into objects such as json, etc. Make a serializers.py on your app directory (like snippets) & type:
from rest_framework import serializers
from snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICES


class SnippetSerializer(serializers.Serializer):
    id = serializers.IntegerField(read_only=True)
    title = serializers.CharField(required=False, allow_blank=True, max_length=100)
    code = serializers.CharField(style={'base_template': 'textarea.html'})
    linenos = serializers.BooleanField(required=False)
    language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python')
    style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly')

    def create(self, validated_data):
        """
        Create and return a new `Snippet` instance, given the validated data.
        """
        return Snippet.objects.create(**validated_data)

    def update(self, instance, validated_data):
        """
        Update and return an existing `Snippet` instance, given the validated data.
        """
        instance.title = validated_data.get('title', instance.title)
        instance.code = validated_data.get('code', instance.code)
        instance.linenos = validated_data.get('linenos', instance.linenos)
        instance.language = validated_data.get('language', instance.language)
        instance.style = validated_data.get('style', instance.style)
        instance.save()
        return instance


*Working with Serializers:
- Now let's add some data in db by python3 manage.py shell. Example:

	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer
	from rest_framework.renderers import JSONRenderer
	from rest_framework.parsers import JSONParser

	sn1 = Snippet(code='new = "one"')
	sn1.save()

	sn1 = Snippet(code='print("hello, world")')
	sn1.save()

- Since our sn1's last value is code='print("hello world")', that wil be what we use
in future steps. Now let's serializing that instance by typing ff. in shell:

	srl = SnippetSerializer(sn1)
	srl.data

- At this point we've translated the model instance into Python native datatypes. To finalize the serialization process we render the data into json.
	
	cnt = JSONRenderer().render(srl.data)
	cnt # it returns now the json

- Deserialization is similar. First we parse a stream into Python native datatypes

	import io
	stream = io.BYTESIO(cnt)
	data = JSONParser().parse(stream)

- And we can restore them into native datatypes by:
	
	serializer = SnippetSerializer(data=data)
	serializer.is_valid()
	# True
	serializer.validated_data
	# OrderedDict([('title', ''), ('code', 'print("hello, world")\n'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])
	serializer.save()
	# <Snippet: Snippet object>


*Working with ModelSerializers:
In the same way that Django provides both Form classes and ModelForm classes, REST
framework includes both Serializer classes, and ModelSerializer classes.
Let's look at refactoring our serializer using the ModelSerializer class. Open the
file snippets/serializers.py again, and replace the SnippetSerializer with the ff:

	class SnippetSerializer(serializers.ModelSerializer):
		class Meta:
			model = Snippet
			fields = ['id', 'title', 'code', 'linenos', 'language', 'style']

- You can analyze the serializer instance of serializers by printing its
representation(repr()) in shell. Once you import SnippetSerializer in
snipppet.serializers try:

	srl = SnippetSerializer()
	print(repr(srl))

- Our modelSerializer is has nothing to do. Just the default create() & update(). It 
all happens because of our class Meta. It dictates our instances how to behave.


*Writing Views using our Serializers:
- The root of our API is going to be a view that supports listing all the existing
snippets, or creating a new snippet:

	from django.http import HttpResponse, JsonResponse
	from django.views.decorators.csrf import csrf_exempt
	from rest_framework.parsers import JSONParser
	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer

	# csrf_exempt because we don't have csrf_token
	@csrf_exempt
	def snippet_list(request):
		"""
		List all code snippets, or create a new snippet.
		"""
		if request.method == 'GET':
			snippets = Snippet.objects.all()
			serializer = SnippetSerializer(snippets, many=True)
			return JsonResponse(serializer.data, safe=False)

		elif request.method == 'POST':
			data = JSONParser().parse(request)
			serializer = SnippetSerializer(data=data)
			if serializer.is_valid():
				serializer.save()
				return JsonResponse(serializer.data, status=201)
			return JsonResponse(serializer.errors, status=400)

- We'll also need a view which corresponds to an individual snippet, and can be used
to retrieve, update or delete the snippet:

	@csrf_exempt
	def snippet_detail(request, pk):
	    """
	    Retrieve, update or delete a code snippet.
	    """
	    try:
	        snippet = Snippet.objects.get(pk=pk)
	    except Snippet.DoesNotExist:
	        return HttpResponse(status=404)

	    if request.method == 'GET':
	        serializer = SnippetSerializer(snippet)
	        return JsonResponse(serializer.data)

	    elif request.method == 'PUT':
	        data = JSONParser().parse(request)
	        serializer = SnippetSerializer(snippet, data=data)
	        if serializer.is_valid():
	            serializer.save()
	            return JsonResponse(serializer.data)
	        return JsonResponse(serializer.errors, status=400)

	    elif request.method == 'DELETE':
	        snippet.delete()
	        return HttpResponse(status=204)

- In able to connect wwith this, we should edit our snippets/urls.py:

	from django.urls import path
	from snippets import views

	urlpatterns = [
		path('snippets/', views.snippet_list),
		path('snippets/<int:pk>/', views.snippet_detail),
	]

- In tutorial/urls.py:
	from django.urls import path, include

	urlpatterns = [
		path('', include('snippets.urls')),
	]

- Now we cam try our code by running the server: python3 manage.py 



## REQUEST AND RESPONSE

*Request objects:
- REST framework introduces a 'Request' object that extends the regular 'HttpRequest',
and provides more flexible request parsing. The core functionality of the 'Request'
object is the 'request.data' attribute, which is similar to 'request.POST', but more
useful for working with Web APIs.
	request.POST  # Only handles form data. Only works for 'POST' method
	request.data  # Handles arbitrary data. Works for 'POST', 'PUT' and 'PATCH' method

*Response objects:
- REST framework also introduces a 'Response' object, which is a type of
TemplateResponse' that takes unrendered content and uses content negotiation to
determine the correct content type to return to the client.
	return Response(data)  # Renders to content type as requested by the client.

*Status code
- Using numeric HTTP status codes in your views doesn't always make for obvious
reading, and it's easy to not notice if you get an error code wrong. REST framework
provides more explicit identifiers for each status code, such as HTTP_400_BAD_REQUEST
in the status module.

*Wrapping API views:
- REST framework provides two wrappers you can use to write API views.
	a. '@api_view' decorator for working with function based views.
		if you're using function api views:
		 -from rest_framework.decorators import api_view
		 -@api_view(['GET', 'POST'])
		 -def snippet_list(request,format=None):

	b. 'APIView' class for working with class-based views.
		if you're using class api views:
		 -from rest_framework.views import APIView
		 -class snippetList(APIView):


- These wrappers provide a few bits of functionality such as making sure you receive 
Request instances in your view, and adding context to Response objects so that 
content negotiation can be performed. The wrappers also provide behaviour such as 
returning 405 Method Not Allowed responses when appropriate, and handling any 
ParseError exceptions that occur when accessing request.data with malformed input.

-Now let's slightly modify the snippet_list() and let's use the '@api_view' decorator:

	from rest_framework import status
	from rest_framework.decorators import api_view
	from rest_framework.response import Response
	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer

	@api_view(['GET', 'POST'])
	def snippet_list(request):
		"""
		List all code snippets, or create a new snippet.
		"""
		if request.method == 'GET':
			snippets = Snippet.objects.all()
			serializer = SnippetSerializer(snippets, many=True)
			return Response(serializer.data)

		elif request.method == 'POST':
			serializer = SnippetSerializer(data=request.data)
			if serializer.is_valid():
				serializer.save()
				return Response(serializer.data, status=status.HTTP_201_CREATED)
			return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

- Also modify the snippe_detail():
	@api_view(['GET', 'PUT', 'DELETE'])
	def snippet_detail(request, pk):
		"""
		Retrieve, update or delete a code snippet.
		"""
		try:
			snippet = Snippet.objects.get(pk=pk)
		except Snippet.DoesNotExist:
			return Response(status=status.HTTP_404_NOT_FOUND)

		if request.method == 'GET':
			serializer = SnippetSerializer(snippet)
			return Response(serializer.data)

		elif request.method == 'PUT':
			serializer = SnippetSerializer(snippet, data=request.data)
			if serializer.is_valid():
				serializer.save()
				return Response(serializer.data)
			return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

		elif request.method == 'DELETE':
			snippet.delete()
			return Response(status=status.HTTP_204_NO_CONTENT)


* Adding optional 'format' suffixes to our URLs:
-  Using format suffixes gives us URLs that explicitly refer to a given format, and 
means our API will be able to handle URLs such as http://example.com/api/items/4.json.
Start by adding a format keyword argument to both of the views:
	def snippet_list(request, format=None), def snippet_detail(request, format=None)

- Modify the snippets/urls.py:
	from django.urls import path
	from snippets import views
	from rest_framework.urlpatterns import format_suffix_patterns

	urlpatterns = [
		path('snippets/', views.snippet_list),
		path('snippets/<int:pk>/', views.snippet_detail),
	]
	urlpatterns = format_suffix_patterns(urlpatterns))

- Now we can test our api after running by:
	http http://127.0.0.1:8000/snippets.json  # JSON suffix
	http http://127.0.0.1:8000/snippets.api   # Browsable API suffix

- Our default client-based response to their request was an HTML formatted page 
for repr (representation).



## CLASS-BASED VIEWS

*Modifying our views to class based api views:

	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer
	from django.http import Http404
	from rest_framework.views import APIView
	from rest_framework.response import Response
	from rest_framework import status

	class SnippetList(APIView):
		"""
		List all snippets, or create a new snippet.
		"""
		def get(self, request, format=None):
			snippets = Snippet.objects.all()
			serializer = SnippetSerializer(snippets, many=True)
			return Response(serializer.data)

		def post(self, request, format=None):
			serializer = SnippetSerializer(data=request.data)
			if serializer.is_valid():
				serializer.save()
				return Response(serializer.data, status=status.HTTP_201_CREATED)
			return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

	class SnippetDetail(APIView):
		"""
		Retrieve, update or delete a snippet instance.
		"""
		def get_object(self, pk):
			try:
				return Snippet.objects.get(pk=pk)
			except Snippet.DoesNotExist:
				raise Http404

		def get(self, request, pk, format=None):
			snippet = self.get_object(pk)
			serializer = SnippetSerializer(snippet)
			return Response(serializer.data)

		def put(self, request, pk, format=None):
			snippet = self.get_object(pk)
			serializer = SnippetSerializer(snippet, data=request.data)
			if serializer.is_valid():
				serializer.save()
				return Response(serializer.data)
			return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

		def delete(self, request, pk, format=None):
			snippet = self.get_object(pk)
			snippet.delete()
			return Response(status=status.HTTP_204_NO_CONTENT)


*Modify our snippets/urls.py/urlpatterns also:

-Before:
	urlpatterns = [
		path('snippets/', views.snippet_list),
		path('snippets/<int:pk>/', views.snippet_detail),
	]

After:
	urlpatterns = [
		path('snippets/', views.SnippetList.as_view()),
		path('snippets/<int:pk>/', views.SnippetDetail.as_view()),
	]


*Using Mixins:

	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer
	from rest_framework import mixins
	from rest_framework import generics

	class SnippetList(mixins.ListModelMixin,
					mixins.CreateModelMixin,
					generics.GenericAPIView):
		queryset = Snippet.objects.all()
		serializer_class = SnippetSerializer

		def get(self, request, *args, **kwargs):
			return self.list(request, *args, **kwargs)

		def post(self, request, *args, **kwargs):
			return self.create(request, *args, **kwargs)

- Here, the 'mixins.ListModeMixin' does the '.list()' job (the get method) and 
'mixins.CreateModeMixin' does the '.create()' job (the post method) while the 
'generics.GenericAPIView' is the responsible of the views just like the APIView on 
class based api view but has limited actions.

	class SnippetDetail(mixins.RetrieveModelMixin,
						mixins.UpdateModelMixin,
						mixins.DestroyModelMixin,
						generics.GenericAPIView):
		queryset = Snippet.objects.all()
		serializer_class = SnippetSerializer

		def get(self, request, *args, **kwargs):
			return self.retrieve(request, *args, **kwargs)

		def put(self, request, *args, **kwargs):
			return self.update(request, *args, **kwargs)

		def delete(self, request, *args, **kwargs):
			return self.destroy(request, *args, **kwargs)
- Pretty similar. Again we're using the GenericAPIView class to provide the core 
functionality, and adding in mixins to provide the '.retrieve()', '.update()' and 
'.destroy()' actions.


*Using generic class-based views:
Using the mixin classes we've rewritten the views to use slightly less code than 
before, but we can go one step further. REST framework provides a set of already 
mixed-in generic views that we can use to trim down our views.py module even more.

	from snippets.models import Snippet
	from snippets.serializers import SnippetSerializer
	from rest_framework import generics


	class SnippetList(generics.ListCreateAPIView):
		queryset = Snippet.objects.all()
		serializer_class = SnippetSerializer


	class SnippetDetail(generics.RetrieveUpdateDestroyAPIView):
		queryset = Snippet.objects.all()
		serializer_class = SnippetSerializer



## USER AUTHENTICATIONS ##
*Adding user information to our model:

- Let's add some fields first. One of those fields will be used to represent the user 
who created the code snippet. The other field will be used to store the highlighted 
HTML representation of the code. Now let's modify the snippets/models.py/snippet():

	owner = models.ForeignKey('auth.User', related_name='snippets', on_delete=models.CASCADE)
	highlighted = models.TextField()

- We'd also need to make sure that when the model is saved, that we populate the 
highlighted field, using the pygments code highlighting library:

	from pygments.lexers import get_lexer_by_name
	from pygments.formatters.html import HtmlFormatter
	from pygments import highlight

- Now let's add save() method in our class:

	def save(self, *args, **kwargs):
		"""
		Use the `pygments` library to create a highlighted HTML
		representation of the code snippet.
		"""
		lexer = get_lexer_by_name(self.language)
		linenos = 'table' if self.linenos else False
		options = {'title': self.title} if self.title else {}
		formatter = HtmlFormatter(style=self.style, linenos=linenos,
									full=True, **options)
		self.highlighted = highlight(self.code, lexer, formatter)
		super(Snippet, self).save(*args, **kwargs)

- After this, we need to start overall again. We need to erase the old db and make new
migrations to avoid errors in migrations because the old model doesn't fit the new 
models. It throws error because some old attributes are lost and replaced new ones. 
The easiest way to do this is:

	rm -f db.sqlite3
	rm -r snippets/migrations
	python manage.py makemigrations snippets
	python manage.py migrate

- And now create a new superuser: python3 manage.py createsuperuser


*Adding endpoints for user models

- Now that we've got some users to work with, we'd better add representations of 
those users to our API. Creating a new serializer is easy. In serializers.py add:

	from django.contrib.auth.models import User

	class UserSerializer(serializers.ModelSerializer):
		snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all())

		class Meta:
			model = User
			fields = ['id', 'username', 'snippets']

- We'd like to just use read-only views for the user representations, so we'll use 
the ListAPIView and RetrieveAPIView generic class-based views. Now add the ff. in our
views.py:

	from django.contrib.auth.models import User

	class UserList(generics.ListAPIView):
		queryset = User.objects.all()
		serializer_class = UserSerializer

	class UserDetail(generics.RetrieveAPIView):
		queryset = User.objects.all()
		serializer_class = UserSerializer

- Make sure to also import the UserSerializer class:

	from snippets.serializers import UserSerializer

- Finally we need to add those views into the API, by referencing them from the URL 
conf. Add the following to the patterns in snippets/urls.py.

	path('users/', views.UserList.as_view()),
	path('users/<int:pk>/', views.UserDetail.as_view()),

The user isn't sent as part of the serialized representation, but is instead a 
property of the incoming request. The way we deal with that is by overriding a 
.perform_create() method on our snippet views, that allows us to modify how the 
instance save is managed, and handle any information that is implicit in the incoming 
request or requested URL. On the views.py/SnippetList view class, add the following 
method:

	def perform_create(self, serializer):
		serializer.save(owner=self.request.user)

- The create() method of our serializer will now be passed an additional 'owner' field, along with the validated data from the request.


*Updating our serializers

- Now that snippets are associated with the user that created them, let's update our 
serializers.py/SnippetSerializer() to reflect that, so add the ff.:

	owner = serializers.ReadOnlyField(source='owner.username')

- Note: Make sure you also add 'owner', to the list of fields in the inner Meta class.

- The source argument controls which attribute is used to populate a field, and can 
point at any attribute on the serialized instance. It can also take the dotted 
notation shown above, in which case it will traverse the given attributes.

- The field we've added is the untyped 'ReadOnlyField' class, in contrast to the 
other typed fields, such as CharField, BooleanField etc... The untyped ReadOnlyField 
is always read-only, and will be used for serialized representations, but will not be 
used for updating model instances when they are deserialized. We could have also used 
CharField(read_only=True) here.


*Adding required permissions to views

- REST framework includes a number of permission classes that we can use to restrict 
who can access a given view. In this case the one we're looking for is 
'IsAuthenticatedOrReadOnly', which will ensure that authenticated requests get 
read-write access, and unauthenticated requests get read-only access.

First add the following import in the views module, then add the ff. property to 
SnippetList and Snippetdetail class:

	from rest_framework import permissions

	class SnippetList():
		# ...

		permission_classes = [permissions.IsAuthenticatedOrReadOnly]

	class SnippetDetail():
		# ...

		permission_classes = [permissions.IsAuthenticatedOrReadOnly]


*Adding logins to our browsable API

- In {project dir}/urls.py;
	
	from django.urls import path, include

	urlpatterns += [
    path('api-auth/', include('rest_framework.urls')), 	# just append this
]


*Object level permissions

- We'd like all code snippets to be visible to anyone, but also make sure that only 
the user that created a code snippet is able to update or delete it. To do that we're 
going to need to create a custom permission. In the snippets app, create a new file, 
permissions.py:

	from rest_framework import permissions

	class IsOwnerOrReadOnly(permissions.BasePermission):
		"""
		Custom permission to only allow owners of an object to edit it.
		"""

		def has_object_permission(self, request, view, obj):
			# Read permissions are allowed to any request,
			# so we'll always allow GET, HEAD or OPTIONS requests.
			if request.method in permissions.SAFE_METHODS:
			    return True

			# Write permissions are only allowed to the owner of the snippet.
			return obj.owner == request.user

- Now we can add that custom permission to our snippet instance endpoint, by editing 
the permission_classes property on the SnippetDetail view class:

permission_classes = [permissions.IsAuthenticatedOrReadOnly,IsOwnerOrReadOnly]

Make sure to also import the IsOwnerOrReadOnly class.

	from snippets.permissions import IsOwnerOrReadOnly

- Now,'DELETE' and 'PUT' actions only appear on a snippet instance endpoint if you're 
logged in as the same user that created the code snippet.


*Authenticating with the API

- Because we now have a set of permissions on the API, we need to authenticate our 
requests to it if we want to edit any snippets. We haven't set up any authentication 
classes, so the defaults are currently applied, which are SessionAuthentication and 
BasicAuthentication.

  When we interact with the API through the web browser, we can login, and the 
browser session will then provide the required authentication for the requests.

- If we're interacting with the API programmatically we need to explicitly provide the authentication credentials on each request.

  If we try to create a snippet without authenticating, we'll get an error. If we're 
logged in, then it will be successful.



## HYPERLINKED APIs & THEIR RELATIONSHIPS

*Creating endpoint of the API

- For now, we have an endpoint for snippets and users, but none in single entrypoint 
of our API. Now let's add one in snippets/views.py:

	from rest_framework.decorators import api_view
	from rest_framework.response import Response
	from rest_framework.reverse import reverse

	@api_view(['GET'])
	def api_root(request, format=None):
		return Response({
			'users': reverse('user-list', request=request, format=format),
			'snippets': reverse('snippet-list', request=request, format=format)
		})

- Two things should be noticed here. First, we're using REST framework's reverse 
function in order to return fully-qualified URLs; second, URL patterns are identified 
by convenience names that we will declare later on in our snippets/urls.py.